# 前端大师课

>  原视频链接：[https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz](https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz)

## 浏览器简介

浏览器是一个多进程多线程的应用，为了避免相互影响，降低崩溃几率，当启动浏览器后，浏览器主进程（浏览器进程）会自动启动多个子进程（如网络进程、渲染进程等）。

### 三大进程

浏览器进程：负责浏览器 GUI 展示、用户事件监听、子进程管理等。浏览器进程内含有多个线程。

网络进程：负责网络资源加载。网络进程内含有多个线程。

渲染进程：渲染主线程负责执行 HTML、CSS、JS 代码。默认情况下，一个标签页就是一个渲染进程。

::: tip 小技巧
可至浏览器 $\to$ 更多工具 $\to$ 任务管理器查看浏览器当前所有进程。
:::

## 事件循环

浏览器事件循环机制的目的是为了解决渲染主线程的任务调度问题，执行过程如下：

![事件循环](/images/事件循环.png)

1. 渲染主线程为死循环。
2. 每一次循环都会检查 MQ 中是否有任务存在，若有则执行 MQ 中第一个任务，执行完后进入下一次循环，若无则进入休眠状态。
3. 浏览器中其他所有线程（包括其他进程的线程）均可随时向 MQ 中添加新任务，在添加新任务时，若渲染主线程为休眠状态则会被唤醒。

### 重点理解

**1. 如何理解 JS 是一门单线程的语言？**

JS 运行在浏览器的渲染主线程中，而浏览器的渲染主线程只有一个，故 JS 是一门单线程的语言。

**2. 如何理解 JS 异步？**

JS 代码在执行过程中，可能会遇到一些无法立即处理的任务，如：

- 定时任务：`setTimeout()`、`setInterval()`
- 网络请求：`XMLHttpRequest`、`fetch()`
- 交互事件：`addEventListener()`

若渲染主线程采用同步的方式处理任务可能会发生**阻塞**，从而导致 MQ 中其他任务无法被执行。在此过程中，渲染主线程会一直等待当前任务执行完毕，从而无法处理其他任务（如渲染页面），可能造成“卡死”现象。

为了避免同步产生的问题，JS 采用**异步**的方式来处理任务。当异步任务发生时，渲染主线程将其交由其他线程处理，自己转而执行后续任务。当其他线程处理完毕时会将事先传递的回调函数包装成任务将其添加至 MQ，等待渲染主线程调度执行。

在异步模式下，浏览器不会发生阻塞，从而最大限度地保证了单线程的流畅运行。

![JS异步](/images/JS异步.png)

**3. JS 的执行为何会阻碍浏览器的渲染？**

JS 的执行与浏览器的渲染使用的是同一个线程——渲染主线程（同一个人），JS 执行时渲染等，渲染执行时 JS 等。

**4. 任务具有优先级吗？**

任务无优先级，MQ 有优先级，微队列中的任务先于所有其他 MQ 中的任务执行，重要 MQ 如下（括号内为优先级）：

- 微队列（最高）：用户存放需要最快执行的任务
- 交互队列（高）：用于存放用户交互事件处理任务
- 延时队列（中）：用于存放计时器计时完毕时的回调任务

常见微任务：`Promise`、`MutationObserver`。

```js
Promise.resolve().then(fn)
```

**5. JS 中的计时器可以做到精确计时吗？为什么？**

不可以，原因如下：

- 计算机硬件无原子钟，无法做到精确计时。
- JS 中的计时器底层实现是调用的操作系统的计时函数，而操作系统本身就存在误差。
- 按照 W3C 标准，JS 中的计时器嵌套超过 5 层时最短延时时间为 4ms，此时若想要延时时间短于 4ms 则必然存在误差。
- 受事件循环机制影响，计时器的回调函数只能在渲染主线程空闲时运行，计时器计时完毕时渲染主线程可能处于繁忙状态，此时需要等待，因此存在一定误差。

## 渲染原理
